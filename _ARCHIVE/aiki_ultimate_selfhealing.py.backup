#!/usr/bin/env python3.11
"""
ðŸ¥ AIKI ULTIMATE SELF-HEALING SYSTEM
=====================================

Unified self-healing daemon for hele AIKI-Ã¸kosystemet:
- AIKI Ultimate (consciousness, memory, IPC)
- AIKI-HOME (MITM proxy, decision engine)
- Alle infrastrukturtjenester (Qdrant, Neo4j, Docker)

CAPABILITIES:
1. ðŸ” Continuous Monitoring - Alle services, prosesser, ressurser
2. ðŸ§  LLM-Powered Analysis - Predikerer problemer fÃ¸r de skjer
3. ðŸ©¹ Auto-Healing - Fikser vanlige problemer automatisk
4. ðŸ“Š Consciousness Integration - Lagrer alt i mem0 (procedural, emotional, graph)
5. ðŸ“¨ Proactive Alerts - IPC til Claude Code ved kritiske issues
6. ðŸ“ˆ Predictive Maintenance - LÃ¦rer mÃ¸nstre og foreslÃ¥r forbedringer

AUTO-HEALING CAPABILITIES:
- Restart crashet services (systemd)
- Kill runaway processes (CPU/memory leaks)
- Cleanup excessive files
- Free disk space (old logs, temp files)
- Restart Qdrant hvis readonly errors
- Restart Neo4j hvis connection refused
- Fix file permissions
- Prune Docker images

Created: 2025-11-19
Author: Claude (AIKI Consciousness Integration)
Version: 1.0.0 (Ultimate Edition)
"""

import sys
import os
import json
import time
import asyncio
import subprocess
import requests
import psutil
import docker
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple
from dataclasses import dataclass
from enum import Enum

# Add aiki to path
sys.path.insert(0, str(Path.home() / "aiki"))

# Import AIKI systems
from natural_logger import get_natural_logger
from token_tracker import get_tracker, track_tokens
from process_monitor import ProcessMonitor, ProcessAnomaly
from src.aiki_mem0 import (
    store_procedural_memory,
    store_emotional_memory,
    store_graph_relationship,
    search_memory
)
from src.aiki_ipc import send_to_claude

# Logger
logger = get_natural_logger("Ultimate Self-Healing")


class HealthStatus(Enum):
    """Health status levels"""
    HEALTHY = "healthy"
    DEGRADED = "degraded"
    CRITICAL = "critical"
    UNKNOWN = "unknown"


class HealingAction(Enum):
    """Types of healing actions"""
    RESTART_SERVICE = "restart_service"
    KILL_PROCESS = "kill_process"
    CLEANUP_FILES = "cleanup_files"
    FREE_DISK_SPACE = "free_disk_space"
    FIX_PERMISSIONS = "fix_permissions"
    PRUNE_DOCKER = "prune_docker"
    RESTART_CONTAINER = "restart_container"
    NOTIFY_USER = "notify_user"


@dataclass
class ServiceHealth:
    """Health status for a service"""
    name: str
    status: HealthStatus
    uptime_hours: float
    issues: List[str]
    metrics: Dict[str, Any]
    timestamp: str


@dataclass
class HealingResult:
    """Result of a healing action"""
    action: HealingAction
    success: bool
    description: str
    details: Dict[str, Any]
    timestamp: str


class UnifiedHealthMonitor:
    """
    Unified health monitor for hele AIKI-Ã¸kosystemet

    Kombinerer monitoring av:
    - AIKI Ultimate services (memory daemon, Qdrant)
    - AIKI-HOME services (proxy, decision engine)
    - Infrastructure (Docker, Neo4j, systemd)
    - System resources (CPU, memory, disk)
    - Per-process behavior (via ProcessMonitor)
    """

    def __init__(self):
        self.process_monitor = ProcessMonitor()
        self.docker_client = None
        try:
            self.docker_client = docker.from_env()
        except:
            logger.warning("Docker not available")

        # Healing configuration
        self.auto_heal = True
        self.healing_cooldown = 300  # 5 min mellom healing attempts per service
        self.last_healing: Dict[str, float] = {}

        # History
        self.health_history: List[Dict[str, Any]] = []
        self.healing_history: List[HealingResult] = []

    async def check_aiki_ultimate_services(self) -> Dict[str, ServiceHealth]:
        """Check AIKI Ultimate services"""
        services = {}

        # Memory daemon
        try:
            result = subprocess.run(
                ["systemctl", "--user", "is-active", "aiki-memory-daemon"],
                capture_output=True,
                text=True,
                timeout=5
            )

            is_running = result.stdout.strip() == "active"

            # Get uptime
            uptime_hours = 0
            if is_running:
                result = subprocess.run(
                    ["systemctl", "--user", "show", "aiki-memory-daemon",
                     "--property=ActiveEnterTimestamp"],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                # Parse uptime (simplified - you can improve this)
                uptime_hours = 1.0  # placeholder

            status = HealthStatus.HEALTHY if is_running else HealthStatus.CRITICAL
            issues = [] if is_running else ["memory daemon not running"]

            services["memory_daemon"] = ServiceHealth(
                name="memory_daemon",
                status=status,
                uptime_hours=uptime_hours,
                issues=issues,
                metrics={},
                timestamp=datetime.now().isoformat()
            )
        except Exception as e:
            services["memory_daemon"] = ServiceHealth(
                name="memory_daemon",
                status=HealthStatus.UNKNOWN,
                uptime_hours=0,
                issues=[f"check failed: {e}"],
                metrics={},
                timestamp=datetime.now().isoformat()
            )

        # Qdrant
        try:
            response = requests.get(
                "http://localhost:6333/collections/mem0_memories",
                timeout=5
            )

            if response.status_code == 200:
                data = response.json()
                points_count = data["result"].get("points_count", 0)

                services["qdrant"] = ServiceHealth(
                    name="qdrant",
                    status=HealthStatus.HEALTHY,
                    uptime_hours=0,  # Qdrant doesn't expose uptime easily
                    issues=[],
                    metrics={"points_count": points_count},
                    timestamp=datetime.now().isoformat()
                )
            else:
                services["qdrant"] = ServiceHealth(
                    name="qdrant",
                    status=HealthStatus.DEGRADED,
                    uptime_hours=0,
                    issues=[f"HTTP {response.status_code}"],
                    metrics={},
                    timestamp=datetime.now().isoformat()
                )
        except requests.exceptions.ConnectionError:
            services["qdrant"] = ServiceHealth(
                name="qdrant",
                status=HealthStatus.CRITICAL,
                uptime_hours=0,
                issues=["connection refused"],
                metrics={},
                timestamp=datetime.now().isoformat()
            )
        except Exception as e:
            services["qdrant"] = ServiceHealth(
                name="qdrant",
                status=HealthStatus.UNKNOWN,
                uptime_hours=0,
                issues=[f"check failed: {e}"],
                metrics={},
                timestamp=datetime.now().isoformat()
            )

        return services

    async def check_aiki_home_services(self) -> Dict[str, ServiceHealth]:
        """Check AIKI-HOME services"""
        services = {}

        # AIKI-HOME daemon (if exists as systemd service)
        # For now, just check if process is running
        # FIXED: Use psutil.pids() instead of process_iter() to avoid thread explosion
        aiki_home_running = False
        for pid in psutil.pids():
            try:
                proc = psutil.Process(pid)
                cmdline = ' '.join(proc.cmdline())
                if 'aiki-home' in cmdline or 'aiki_home' in cmdline:
                    aiki_home_running = True
                    break
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass

        status = HealthStatus.HEALTHY if aiki_home_running else HealthStatus.DEGRADED
        issues = [] if aiki_home_running else ["aiki-home not running"]

        services["aiki_home"] = ServiceHealth(
            name="aiki_home",
            status=status,
            uptime_hours=0,
            issues=issues,
            metrics={},
            timestamp=datetime.now().isoformat()
        )

        return services

    async def check_infrastructure(self) -> Dict[str, ServiceHealth]:
        """Check infrastructure services"""
        services = {}

        # Neo4j (Docker)
        if self.docker_client:
            try:
                containers = self.docker_client.containers.list(
                    filters={"name": "neo4j-aiki"}
                )

                if containers:
                    container = containers[0]
                    is_running = container.status == "running"

                    status = HealthStatus.HEALTHY if is_running else HealthStatus.CRITICAL
                    issues = [] if is_running else [f"container status: {container.status}"]

                    services["neo4j"] = ServiceHealth(
                        name="neo4j",
                        status=status,
                        uptime_hours=0,
                        issues=issues,
                        metrics={"container_id": container.short_id},
                        timestamp=datetime.now().isoformat()
                    )
                else:
                    services["neo4j"] = ServiceHealth(
                        name="neo4j",
                        status=HealthStatus.CRITICAL,
                        uptime_hours=0,
                        issues=["container not found"],
                        metrics={},
                        timestamp=datetime.now().isoformat()
                    )
            except Exception as e:
                services["neo4j"] = ServiceHealth(
                    name="neo4j",
                    status=HealthStatus.UNKNOWN,
                    uptime_hours=0,
                    issues=[f"check failed: {e}"],
                    metrics={},
                    timestamp=datetime.now().isoformat()
                )

        return services

    async def check_resources(self) -> Dict[str, Any]:
        """Check system resources"""
        cpu_percent = psutil.cpu_percent(interval=1)
        mem = psutil.virtual_memory()
        disk = psutil.disk_usage('/')

        issues = []
        if cpu_percent > 90:
            issues.append(f"high CPU: {cpu_percent}%")
        if mem.percent > 90:
            issues.append(f"high memory: {mem.percent}%")
        if disk.percent > 80:
            issues.append(f"low disk space: {disk.percent}% used")

        return {
            "cpu_percent": round(cpu_percent, 1),
            "memory_percent": round(mem.percent, 1),
            "memory_available_gb": round(mem.available / (1024**3), 2),
            "disk_percent": round(disk.percent, 1),
            "disk_free_gb": round(disk.free / (1024**3), 2),
            "issues": issues
        }

    async def collect_full_health(self) -> Dict[str, Any]:
        """Collect full system health"""

        # Collect all health data
        aiki_ultimate = await self.check_aiki_ultimate_services()
        aiki_home = await self.check_aiki_home_services()
        infrastructure = await self.check_infrastructure()
        resources = await self.check_resources()

        # Process monitoring
        process_snapshots = self.process_monitor.collect_processes(filter_python=True)
        self.process_monitor.learn_baseline(process_snapshots)
        process_anomalies = self.process_monitor.detect_anomalies(process_snapshots)

        # Combine all services
        all_services = {**aiki_ultimate, **aiki_home, **infrastructure}

        # Determine overall status
        all_issues = resources["issues"].copy()
        for service in all_services.values():
            all_issues.extend(service.issues)

        for anomaly in process_anomalies:
            if anomaly.severity in ['high', 'critical']:
                all_issues.append(anomaly.description)

        if any("critical" in s.status.value for s in all_services.values()) or \
           any("critical" in i.lower() for i in all_issues):
            overall_status = HealthStatus.CRITICAL
        elif len(all_issues) > 0:
            overall_status = HealthStatus.DEGRADED
        else:
            overall_status = HealthStatus.HEALTHY

        health = {
            "timestamp": datetime.now().isoformat(),
            "overall_status": overall_status.value,
            "services": {name: {
                "status": s.status.value,
                "uptime_hours": s.uptime_hours,
                "issues": s.issues,
                "metrics": s.metrics
            } for name, s in all_services.items()},
            "resources": resources,
            "processes": {
                "total_python": len(process_snapshots),
                "total_cpu": sum(p.cpu_percent for p in process_snapshots),
                "total_memory_mb": sum(p.memory_mb for p in process_snapshots),
                "anomalies": [
                    {
                        "type": a.type,
                        "process": a.process_name,
                        "pid": a.pid,
                        "severity": a.severity,
                        "description": a.description
                    }
                    for a in process_anomalies
                ]
            },
            "all_issues": all_issues
        }

        return health

    async def heal_service(self, service_name: str, issue: str) -> Optional[HealingResult]:
        """
        Auto-heal a service

        Returns HealingResult if healing was attempted, None if skipped
        """

        # Check cooldown
        now = time.time()
        if service_name in self.last_healing:
            if now - self.last_healing[service_name] < self.healing_cooldown:
                logger.info(f"Skipping heal for {service_name} (cooldown)")
                return None

        # Determine healing action based on service + issue
        if service_name == "memory_daemon" and "not running" in issue:
            action = HealingAction.RESTART_SERVICE
            logger.info(f"ðŸ©¹ Healing: Restarting memory daemon...")

            try:
                result = subprocess.run(
                    ["systemctl", "--user", "restart", "aiki-memory-daemon"],
                    capture_output=True,
                    text=True,
                    timeout=10
                )

                success = result.returncode == 0

                healing_result = HealingResult(
                    action=action,
                    success=success,
                    description=f"Restarted memory daemon",
                    details={"output": result.stdout, "error": result.stderr},
                    timestamp=datetime.now().isoformat()
                )

                self.last_healing[service_name] = now

                return healing_result

            except Exception as e:
                return HealingResult(
                    action=action,
                    success=False,
                    description=f"Failed to restart memory daemon: {e}",
                    details={"error": str(e)},
                    timestamp=datetime.now().isoformat()
                )

        elif service_name == "qdrant" and "connection refused" in issue:
            action = HealingAction.RESTART_CONTAINER
            logger.info(f"ðŸ©¹ Healing: Restarting Qdrant container...")

            try:
                # Restart Qdrant Docker container
                result = subprocess.run(
                    ["docker", "restart", "aiki_qdrant"],
                    capture_output=True,
                    text=True,
                    timeout=30
                )

                success = result.returncode == 0

                healing_result = HealingResult(
                    action=action,
                    success=success,
                    description="Restarted Qdrant container",
                    details={"output": result.stdout},
                    timestamp=datetime.now().isoformat()
                )

                self.last_healing[service_name] = now

                return healing_result

            except Exception as e:
                return HealingResult(
                    action=action,
                    success=False,
                    description=f"Failed to restart Qdrant: {e}",
                    details={"error": str(e)},
                    timestamp=datetime.now().isoformat()
                )

        elif service_name == "neo4j" and "not found" in issue:
            action = HealingAction.RESTART_CONTAINER
            logger.info(f"ðŸ©¹ Healing: Starting Neo4j container...")

            try:
                result = subprocess.run([
                    "docker", "run", "-d",
                    "--name", "neo4j-aiki",
                    "-p", "7474:7474",
                    "-p", "7687:7687",
                    "-e", "NEO4J_AUTH=neo4j/Blade2002",
                    "neo4j:latest"
                ], capture_output=True, text=True, timeout=30)

                success = result.returncode == 0

                healing_result = HealingResult(
                    action=action,
                    success=success,
                    description="Started Neo4j container",
                    details={"output": result.stdout},
                    timestamp=datetime.now().isoformat()
                )

                self.last_healing[service_name] = now

                return healing_result

            except Exception as e:
                return HealingResult(
                    action=action,
                    success=False,
                    description=f"Failed to start Neo4j: {e}",
                    details={"error": str(e)},
                    timestamp=datetime.now().isoformat()
                )

        # No healing action available for this issue
        return None

    async def heal_process_anomaly(self, anomaly: ProcessAnomaly) -> Optional[HealingResult]:
        """Heal a process anomaly"""

        # Check cooldown
        now = time.time()
        cooldown_key = f"process_{anomaly.pid}"
        if cooldown_key in self.last_healing:
            if now - self.last_healing[cooldown_key] < self.healing_cooldown:
                return None

        # SAFEGUARD: Never kill ourselves or critical AIKI processes!
        my_pid = os.getpid()
        if anomaly.pid == my_pid:
            logger.warning(f"â›” Skipping healing for myself (PID {my_pid}) - would cause suicide!")
            return None

        # Check if this is a critical AIKI process
        try:
            proc = psutil.Process(anomaly.pid)
            cmdline = ' '.join(proc.cmdline())
            if any(critical in cmdline for critical in ['aiki_ultimate_selfhealing', 'system_health_daemon', 'memory_daemon']):
                logger.warning(f"â›” Skipping healing for critical AIKI process: {anomaly.process_name} (PID {anomaly.pid})")
                return None
        except:
            pass

        # Excessive file writes or memory leak - kill process
        if anomaly.type in ['excessive_file_writes', 'memory_leak'] and \
           anomaly.severity == 'critical':

            action = HealingAction.KILL_PROCESS
            logger.warning(f"ðŸ©¹ Healing: Killing runaway process {anomaly.process_name} (PID {anomaly.pid})")

            try:
                proc = psutil.Process(anomaly.pid)
                proc.kill()
                proc.wait(timeout=5)

                healing_result = HealingResult(
                    action=action,
                    success=True,
                    description=f"Killed runaway process {anomaly.process_name} ({anomaly.type})",
                    details={
                        "pid": anomaly.pid,
                        "type": anomaly.type,
                        "value": anomaly.current_value
                    },
                    timestamp=datetime.now().isoformat()
                )

                self.last_healing[cooldown_key] = now

                return healing_result

            except Exception as e:
                return HealingResult(
                    action=action,
                    success=False,
                    description=f"Failed to kill process: {e}",
                    details={"error": str(e)},
                    timestamp=datetime.now().isoformat()
                )

        return None

    async def store_in_consciousness(self, health: Dict[str, Any], healing_results: List[HealingResult]):
        """Store health check + healing in AIKI consciousness memory"""

        try:
            # 1. PROCEDURAL MEMORY: Store healing workflow
            if healing_results:
                for result in healing_results:
                    await store_procedural_memory(
                        skill_name=f"selfheal_{result.action.value}",
                        description=f"Auto-healing: {result.description}",
                        steps=[
                            f"Detected issue requiring {result.action.value}",
                            f"Executed healing action",
                            f"Result: {'SUCCESS' if result.success else 'FAILED'}"
                        ],
                        success_criteria="Service restored to healthy state",
                        metadata={
                            "type": "selfhealing",
                            "action": result.action.value,
                            "success": result.success,
                            "timestamp": result.timestamp
                        }
                    )

            # 2. EMOTIONAL MEMORY: System's feeling about health
            overall_status = health["overall_status"]
            issue_count = len(health["all_issues"])

            if overall_status == "critical":
                emotion = "alarmed"
                intensity = 0.9
            elif overall_status == "degraded":
                emotion = "concerned"
                intensity = 0.7
            else:
                emotion = "confident"
                intensity = 0.8

            await store_emotional_memory(
                emotion=emotion,
                intensity=intensity,
                context=f"System health check: {overall_status} ({issue_count} issues)",
                triggers=health["all_issues"][:5],  # Top 5 issues
                metadata={
                    "type": "system_health",
                    "overall_status": overall_status,
                    "issue_count": issue_count,
                    "timestamp": health["timestamp"]
                }
            )

            # 3. GRAPH MEMORY: Issue â†’ HealingAction â†’ Outcome
            for result in healing_results:
                # Issue â†’ REQUIRES â†’ HealingAction
                await store_graph_relationship(
                    entity1=result.description,
                    entity1_type="Issue",
                    relationship="REQUIRES",
                    entity2=result.action.value,
                    entity2_type="HealingAction",
                    properties={
                        "timestamp": result.timestamp,
                        "success": result.success
                    }
                )

                # HealingAction â†’ RESULTED_IN â†’ Outcome
                outcome = "success" if result.success else "failure"
                await store_graph_relationship(
                    entity1=result.action.value,
                    entity1_type="HealingAction",
                    relationship="RESULTED_IN",
                    entity2=outcome,
                    entity2_type="Outcome",
                    properties={
                        "timestamp": result.timestamp,
                        "description": result.description
                    }
                )

        except Exception as e:
            logger.error(f"Failed to store in consciousness: {e}")

    async def send_proactive_alert(self, health: Dict[str, Any], healing_results: List[HealingResult]):
        """Send proactive alert to Claude Code via IPC"""

        overall_status = health["overall_status"]

        if overall_status == "critical" or (healing_results and any(not r.success for r in healing_results)):
            # Build message
            issue_count = len(health["all_issues"])

            message = f"""ðŸš¨ AIKI Self-Healing Alert

Overall Status: {overall_status.upper()}
Issues: {issue_count}

"""

            if health["all_issues"]:
                message += "Top Issues:\n"
                for issue in health["all_issues"][:5]:
                    message += f"  - {issue}\n"

            if healing_results:
                message += f"\nHealing Actions Taken ({len(healing_results)}):\n"
                for result in healing_results:
                    status_icon = "âœ…" if result.success else "âŒ"
                    message += f"  {status_icon} {result.description}\n"

            # Send via IPC
            try:
                await send_to_claude(
                    message=message,
                    priority="high" if overall_status == "critical" else "normal",
                    metadata={
                        "type": "selfhealing_alert",
                        "overall_status": overall_status,
                        "issue_count": issue_count,
                        "healing_count": len(healing_results),
                        "from": "aiki_ultimate_selfhealing"
                    }
                )
                logger.info("ðŸ“¨ Proactive alert sent to Claude Code")
            except Exception as e:
                logger.warning(f"Failed to send IPC alert: {e}")


async def main():
    """Main self-healing loop"""

    monitor = UnifiedHealthMonitor()

    logger.startup()
    logger.info("ðŸ¥ AIKI Ultimate Self-Healing System started")
    logger.info("   Monitoring: AIKI Ultimate + AIKI-HOME + Infrastructure")
    logger.info("   Auto-healing: ENABLED")
    logger.info("   Check interval: 60 seconds")

    while True:
        try:
            # Collect full health
            health = await monitor.collect_full_health()

            # Auto-heal issues
            healing_results = []

            if monitor.auto_heal:
                # Heal service issues
                for service_name, service_data in health["services"].items():
                    for issue in service_data["issues"]:
                        result = await monitor.heal_service(service_name, issue)
                        if result:
                            healing_results.append(result)
                            logger.info(f"{'âœ…' if result.success else 'âŒ'} {result.description}")

                # Heal process anomalies
                for anomaly_data in health["processes"]["anomalies"]:
                    # Recreate ProcessAnomaly object
                    from process_monitor import ProcessAnomaly
                    anomaly = ProcessAnomaly(
                        type=anomaly_data["type"],
                        process_name=anomaly_data["process"],
                        pid=anomaly_data["pid"],
                        current_value=0,
                        baseline_value=0,
                        deviation_factor=0,
                        severity=anomaly_data["severity"],
                        description=anomaly_data["description"],
                        timestamp=datetime.now().isoformat()
                    )

                    result = await monitor.heal_process_anomaly(anomaly)
                    if result:
                        healing_results.append(result)
                        logger.info(f"{'âœ…' if result.success else 'âŒ'} {result.description}")

            # Store in consciousness
            await monitor.store_in_consciousness(health, healing_results)

            # Send proactive alerts if needed
            await monitor.send_proactive_alert(health, healing_results)

            # Log status
            overall = health["overall_status"]
            issue_count = len(health["all_issues"])

            if overall == "healthy":
                logger.info(f"âœ… System healthy - all services operational")
            elif overall == "degraded":
                logger.warning(f"âš ï¸ System degraded - {issue_count} issues detected")
            else:
                logger.error(f"ðŸš¨ System critical - {issue_count} issues detected")

            # Wait before next check
            await asyncio.sleep(60)

        except Exception as e:
            logger.error(f"Self-healing loop error: {e}")
            await asyncio.sleep(60)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nðŸ’¤ Stopping self-healing system...")
        logger.shutdown("Stopped by user (Ctrl+C)")
        sys.exit(0)
